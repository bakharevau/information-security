
def find_nod(a, b):
    """
        Нахождение НОД с помощью алгоритма Эвклида
    """
    while(b):
        if b > a:
            a, b = b, a
        a, b = b, a % b
    return a


def prime(n):
    """
        Функция возвращает множество простых чисел не превосходящих n
    """
    # список заполняется значениями от 0 до n
    a = []
    for i in range(n + 1):
        a.append(i)

    # Вторым элементом является единица,
    # которую не считают простым числом
    # забиваем ее нулем.
    a[1] = 0

    # начинаем с 3-го элемента
    i = 2
    while i <= n:
        # Если значение ячейки до этого
        # не было обнулено,
        # в этой ячейке содержится
        # простое число.
        if a[i] != 0:
            # первое кратное ему
            # будет в два раза больше
            j = i + i
            while j <= n:
                # это число составное,
                # поэтому заменяем его нулем
                a[j] = 0
                # переходим к следующему числу,
                # которое кратно i
                # (оно на i больше)
                j = j + i
        i += 1

    # Превращая список во множество,
    # избавляемся от всех нулей кроме одного.
    a = set(a)
    # удаляем ноль
    a.remove(0)

    return a


def eiler_func(n: int):
    """
        Функция возвращает значение функции Эйлера для числа n
    """
    result = 0
    numbers = []

    for i in range(1, n):
        if find_nod(i, n) == 1:
            result += 1
            numbers.append(i)
    print(numbers)
    return result


def solve_linear_congruence(a, b, m):
    """
        Находит решение линейного сравнения по алгоритму из методички
    """
    print('-----------------------------')
    print(f'Находим решение линейного сравнения: {a}x = {b} mod {m} \n')
    print('Дано:', a, 'x =', b, 'mod', m)
    temp_m = m
    if find_nod(a, b) != 1:
        return print("Нет единственного решения")
    q = []
    q.append(1)
    p = []
    if a == m:
        q.append(a)
    while a != 0 and m != 0:
        if a > m:
            q.append(a // m)
            a = a % m
        else:
            q.append(m // a)
            m = m % a

    n = len(q) - 1
    p.append(q[0])
    p.append(q[1])
    for i in range(2, n):
        p.append(q[i] * p[i - 1] + p[i - 2])

    x = pow(-1, n - 1) * p[n - 1] * b
    result = x % temp_m
    print('x =', x, 'mod', temp_m)
    print('Ответ:', result)
    print('-----------------------------')
    return result


def solve_linear_congruence_2(a, b, m):
    """ 
        Находит все решения для линейного сравнения ax = b(mod m)
        Первое, что нужно вычислить, - это наибольший общий делитель g чисел a и m. 
        Есть два случая:
        если b не делится на g, то сравнение не имеет решений (если ax + my = b для некоторых целых чисел x и y, 
        то любой общий делитель a и m также должны быть делителем b)
        если b кратно g, то сравнение в точности эквивалентно (a/g)x = (b/g) (mod (m/g)). 
        Теперь a/g и m/g взаимно просты, поэтому можно вычислить обратное к a/g по модулю m/g (возведение в степень -1 по модулю). 
        Умножение этого обратного на b/g дает решение, 
        а общее решение может быть получено добавлением к этому решению произвольного кратного m/g.
    """
    g = find_nod(a, m)
    if b % g:
        raise ValueError("Нет решений")
    a, b, m = a//g, b//g, m//g
    return pow(a, -1, m) * b % m, m


def primfacs(n):
    """
        Задание 2. Найти каноническое разложение числа n
    """
    i = 2
    primfac = []
    while i * i <= n:
        while n % i == 0:
            primfac.append(i)
            n = n // i
        i = i + 1
    if n > 1:
        primfac.append(n)
    return primfac
